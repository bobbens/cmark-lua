#!/usr/bin/env lua

-- package.path='./?.lua;' .. package.path -- UNCOMMENT FOR TESTING
local alt_getopt = require("alt_getopt")
local cmark = require("cmark")
local luacmark = require("luacmark")
local Lust = require("lust")

local manpage = [==[
# NAME

luacmark - command line CommonMark parser and renderer

# SYNOPSIS

luacmark [options] [file..]

# DESCRIPTION

TODO description here.

TODO for options, create a filter that makes these look right in
man.

# OPTIONS

* `--to,-t` *format*

    Specify format for output.
    *format* can be `commonmark`, `html`, `man`, `xml`, or `latex`.

* `--output,-o` *file*

    Write output to *file*.

* `--columns,-c` *NUMBER*

    Specify number of columns for text wrapping in supported
    formats.  The default is 0 = no wrapping.

* `--filter,-F` *file[,file]*

    Filter the parsed AST using a lua script.  TODO details.

* `--template,-T` *file*

    Insert converted text and metadata into a template.  See TEMPLATES,
    below, for template format.

* `--smart`

    Enable smart typography (straight quotes are turned into
    curly quotes, `--` into en dashes, `---` into em dashes,
    `...` into ellipses).

* `--safe`

    Suppress raw HTML and unsafe links (`javascript:`, `file:`,
    `vbscript:`, and `data:`, except for `image/png`, `image/gif`,
    `image/jpeg`, or `image/webp` mime types).

* `--hardbreaks`

    Render softbreak elements (newlines in paragraphs) as hard
    line breaks.

* `--sourcepos`

    Include source position information in html/xml attributes.

* `--man,-M`

    Print out the man page.

* `--version,-V`

    Print version information.

* `--help,-h`

    This message

# TEMPLATES

By default, luacmark will produce a fragment.  If the
`--template` option is specified, it will insert
this fragment into a template, producing a standalone document with
appropriate header and footer.  The template is
sought first in the working directory, then in
`templates`, and finally in `$HOME/luacmark/templates`. If no
extension is given, the name of the writer will be used as an
extension. So, for example, one can put the template `letter.html`
in the `$HOME/luacmark/templates` directory, and use it anywhere
with `luacmark --template letter`.

The templates are [Lust](https://github.com/weshoke/Lust) templates.
TODO describe.

Variables are taken from YAML metadata; the fields are interpreted
as CommonMark and rendered appropriately for the output format.
The following additional variables are set automatically:

* `body`: the document body

# EXAMPLES

    luacmark

acts as a filter, reading markdown from stdin and writing
HTML to stdout.

    luacmark --smart -t latex

acts as a filter, reading markdown with smart typography
and definition list extensions from stdin, and writing
LaTeX to stdout.

    luacmark -t latex -o mybook.tex ch{1,2,3}.txt references.txt

reads `ch1.txt`, `ch2.txt`, `ch3.txt`, and `references.txt`,
concatenates them, and converts the result from markdown to LaTeX.

    luacmark --template letter -d cc=Smith,cc="Jim Jones",sign="yes" \
      -t latex -o myletter.tex myletter.txt

produces a LaTeX file using the template `letter.latex`,
and setting the variable `cc` to `{"Smith","Jim Jones"}`
and `sign` to `"yes"`.

# AUTHORS

luacmark is written by John MacFarlane.
]==]


local function err(msg, exit_code)
  io.stderr:write("luacmark: " .. msg .. "\n")
  os.exit(exit_code or 1)
end

local function ensure_one_of(optval,s,ary)
  for i=1,#ary do
    if ary[i]==s then return true end
  end
  err("Illegal value for " .. optval ..
     "\nLegal values are: " .. table.concat(ary,", "))
end

--- Find a template and return its contents (or `false` if
-- not found). The template is sought first in the
-- working directory, then in `templates`, then in
-- `$HOME/.lunamark/templates`, then in the Windows
-- `APPDATA` directory.
local find_template = function(name, to)
  if not name then
    return false, "Missing template name"
  end
  local base, ext = name:match("([^%.]*)(.*)")
  if (not ext or ext == "") and to then
    ext = "." .. to
  end
  local fname = base .. ext
  local file = io.open(fname, "r")
  if not file then
    file = io.open("templates/" .. fname, "r")
  end
  if not file then
    local home = os.getenv("HOME")
    if home then
      file = io.open(home .. "/.luacmark/templates/" .. fname, "r")
    end
  end
  if not file then
    local appdata = os.getenv("APPDATA")
    if appdata then
      file = io.open(appdata .. "/luacmark/templates/" .. fname, "r")
    end
  end
  if file then
    return file:read("*all")
  else
    return false, "Could not find template '" .. fname .. "'"
  end
end


local usage = [[
Usage: luacmark [options] [file..] - convert markdown to other formats

Options:
  --to,-t FORMAT             Target format
  --output,-o FILE           Output file
  --filter,-F FILE,[,FILE]   Lua script to filter AST
  --template,-T FILE         Insert output into template
  --columns,c NUMBER         Number of columns to wrap text (or 0 for no wrap)
  --smart,-S                 Smart punctuation
  --safe,-s                  Omit HTML and potentially unsafe attributes
  --hardbreaks,-h            Treat softbreaks as hard line breaks
  --sourcepos,-p             Include source position information
  --man,-M                   Print man page
  --version,-V               Version information
  --help,-h                  This message

FORMAT can be html, latex, man, commonmark, or xml.
]]

local long_opts = {
  to = "t",
  columns = "c",
  smart = "S",
  hardbreaks = "h",
  sourcepos = "p",
  safe = "s",
  output = "o",
  filter = "F",
  template = "T",
  version = "V",
  man = "M",
  help = "h"
}

local short_opts = "t:o:c:F:T:sSphVMh"

local optarg,optind = alt_getopt.get_opts(arg, short_opts, long_opts)

if optarg.h then
  io.write(usage)
  os.exit(0)
end

if optarg.M then
  local manpagedoc = cmark.parse_document(manpage, string.len(manpage),
                        cmark.OPT_DEFAULT)
  io.write('.TH LUACMARK 1 "" "luacmark ' .. luacmark.version .. '"\n')
  io.write(cmark.render_man(manpagedoc, cmark.OPT_DEFAULT, 72))
  os.exit(0)
end

if optarg.V then
  io.write("luacmark " .. luacmark.version .. "\nCopyright 2015 John MacFarlane\n")
  os.exit(0)
end

local to = optarg.t or "html"
ensure_one_of("--to,-t", to,
  {"commonmark","html","latex","man","xml"})

local output = optarg.o
local ok, msg = pcall(function() io.output(output) end)
if not ok then
  err("Could not open '" .. output .. "' for writing.\n" .. msg, 9)
end

local options = {
  smart = optarg.S,
  hardbreaks = optarg.h,
  safe = optarg.s,
  sourcepos = optarg.p,
  columns = optarg.c or 0,
  yaml_metadata = true,
  filter = nil,
}

local filters = {}
if optarg['F'] then
  for filter in string.gmatch(optarg['F'], "([^,]+)") do
    local f, msg = luacmark.to_filter(io.lines(filter, 2^12), filter)
    if f then
      table.insert(filters, f)
    else
      err("Error loading filter " .. filter .. "\n" .. msg)
    end
  end
  -- filters now contains our filters
  options.filter = function(doc, to)
    for _,f in ipairs(filters) do
      f(doc,to)
    end
  end
end

-- TODO replace with error handling in convert
-- local writer = luacmark.writers[to]
-- if not writer then
--   err("Unknown writer: " .. tostring(to), 5)
-- end

local args = {}
for i=optind,#arg do
  table.insert(args,arg[i])
end

local inp
if #args == 0 then
  inp = io.read("*all")
else
  inpt = {}
  for _,f in ipairs(args) do
    local ok, msg = pcall(function() io.input(f) end)
    if ok then
      table.insert(inpt, io.read("*all"))
    else
      err("Could not open file '" .. f .. "'", 7)
    end
  end
  inp = table.concat(inpt, "\n")
end

local body, data, msg = luacmark.convert(inp, to, options)
if body then
  local template = find_template(optarg.T, to)
  if template then
    data.body = body
    io.write(Lust(template):gen(data))
  else
    io.write(body)
  end
else
  err(msg)
end

